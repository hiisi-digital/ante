//----------------------------------------------------------------------------------------------------
// Copyright (c) 2025                    orgrinrt                    orgrinrt@ikiuni.dev
// SPDX-License-Identifier: MPL-2.0      https://mozilla.org/MPL/2.0 contact@hiisi.digital
//----------------------------------------------------------------------------------------------------

/**
 * Git hooks management for ante.
 *
 * Provides functions for generating, installing, and managing git hooks
 * that enforce copyright header policies.
 */

import type { ResolvedConfig } from "#core";

/**
 * Default hooks directory name.
 */
const HOOKS_DIR = ".githooks";

/**
 * Generates the content for the shared shell functions file.
 * This contains reusable functions used by the pre-commit hook.
 */
export function generateFunctionsScript(config: ResolvedConfig): string {
  return `#!/bin/bash
#----------------------------------------------------------------------------------------------------
# ante - Copyright header management - Shared functions
# Auto-generated by ante. Do not edit manually.
#----------------------------------------------------------------------------------------------------

# Configuration values from deno.json
WIDTH=${config.width}
SEPARATOR_CHAR="${config.separatorChar}"
COMMENT_PREFIX="${config.commentPrefix}"
NAME_COL=${config.nameColumn}
EMAIL_COL=${config.emailColumn}
LICENSE_URL_COL=${config.licenseUrlColumn}
MAINTAINER_COL=${config.maintainerColumn}
SPDX_LICENSE="${config.spdxLicense}"
LICENSE_URL="${config.licenseUrl}"
MAINTAINER_EMAIL="${config.maintainerEmail}"

# Generate separator line
generate_separator() {
    local len=$((WIDTH - \${#COMMENT_PREFIX}))
    printf "%s" "$COMMENT_PREFIX"
    printf '%*s' "$len" '' | tr ' ' "$SEPARATOR_CHAR"
    echo
}

# Format a copyright line with column alignment
format_copyright_line() {
    local year_part="$1"
    local name="$2"
    local email="$3"
    
    local prefix
    if [ -n "$year_part" ]; then
        prefix="$COMMENT_PREFIX Copyright (c) $year_part"
    else
        prefix="$COMMENT_PREFIX"
    fi
    
    local prefix_len=\${#prefix}
    local padding_to_name=$((NAME_COL - prefix_len))
    [ "$padding_to_name" -lt 1 ] && padding_to_name=1
    
    local name_end=$((NAME_COL + \${#name}))
    local padding_to_email=$((EMAIL_COL - name_end))
    [ "$padding_to_email" -lt 1 ] && padding_to_email=1
    
    printf "%s%*s%s%*s%s\\n" "$prefix" "$padding_to_name" "" "$name" "$padding_to_email" "" "$email"
}

# Format SPDX line
format_spdx_line() {
    local spdx_part="$COMMENT_PREFIX SPDX-License-Identifier: $SPDX_LICENSE"
    local spdx_len=\${#spdx_part}
    
    local padding_to_url=$((LICENSE_URL_COL - spdx_len))
    [ "$padding_to_url" -lt 1 ] && padding_to_url=1
    
    local url_end=$((LICENSE_URL_COL + \${#LICENSE_URL}))
    local padding_to_maintainer=$((MAINTAINER_COL - url_end))
    [ "$padding_to_maintainer" -lt 1 ] && padding_to_maintainer=1
    
    printf "%s%*s%s%*s%s\\n" "$spdx_part" "$padding_to_url" "" "$LICENSE_URL" "$padding_to_maintainer" "" "$MAINTAINER_EMAIL"
}

# Check if file has a copyright header
has_copyright_header() {
    local file="$1"
    head -1 "$file" 2>/dev/null | grep -q "^$COMMENT_PREFIX[-=*]" && \\
    head -2 "$file" 2>/dev/null | tail -1 | grep -q "Copyright (c)"
}

# Check if user email is in header
user_in_header() {
    local file="$1"
    local email="$2"
    head -10 "$file" 2>/dev/null | grep -q "$email"
}

# Get first copyright year from header
get_first_year() {
    local file="$1"
    head -2 "$file" | tail -1 | sed -n 's/.*Copyright (c) \\([0-9]\\{4\\}\\).*/\\1/p'
}

# Create new copyright header
create_copyright_header() {
    local file="$1"
    local name="$2"
    local email="$3"
    local year="$4"
    
    local tmp_file
    tmp_file=$(mktemp)
    
    {
        generate_separator
        format_copyright_line "$year" "$name" "$email"
        format_spdx_line
        generate_separator
        echo
        cat "$file"
    } > "$tmp_file"
    
    mv "$tmp_file" "$file"
}

# Add contributor to existing header
add_contributor_to_header() {
    local file="$1"
    local name="$2"
    local email="$3"
    
    local new_line
    new_line=$(format_copyright_line "" "$name" "$email")
    
    local spdx_line_num
    spdx_line_num=$(grep -n "SPDX-License-Identifier" "$file" | head -1 | cut -d: -f1)
    
    if [ -n "$spdx_line_num" ]; then
        sed -i.bak "\${spdx_line_num}i\\\\
\${new_line}
" "$file"
        rm -f "\${file}.bak"
    fi
}

# Update year range in header
update_year_in_header() {
    local file="$1"
    local first_year="$2"
    local current_year="$3"
    
    if [ "$first_year" = "$current_year" ]; then
        return 0
    fi
    
    if head -2 "$file" | tail -1 | grep -q "\${first_year}-\${current_year}"; then
        return 0
    fi
    
    # Simple replacement
    sed -i.bak "2s/Copyright (c) \${first_year}[^ ]*/Copyright (c) \${first_year}-\${current_year}/" "$file"
    rm -f "\${file}.bak"
    return 1
}
`;
}

/**
 * Generates the content for the pre-commit hook script.
 */
export function generatePreCommitHook(): string {
  return `#!/bin/sh
#----------------------------------------------------------------------------------------------------
# ante - Copyright header management - Pre-commit hook
# Auto-generated by ante. Do not edit manually.
#----------------------------------------------------------------------------------------------------
#
# This hook:
# 1. Checks if staged .ts files have a copyright header
# 2. If missing, creates one with the current git user
# 3. If present but current user not listed, adds them
# 4. Updates copyright year range when files change
#

# Get the directory where this hook script is located
HOOK_DIR="$(cd "$(dirname "$0")" && pwd)"

# Source the shared functions
. "\${HOOK_DIR}/functions.sh"

# Get current git user info
GIT_USER_NAME=$(git config user.name || echo "")
GIT_USER_EMAIL=$(git config user.email || echo "")
CURRENT_YEAR=$(date +%Y)

# Ensure we have git user info
if [ -z "$GIT_USER_NAME" ] || [ -z "$GIT_USER_EMAIL" ]; then
    echo "Warning: Git user.name or user.email not configured."
    echo "Skipping copyright header management."
    exit 0
fi

# Track if any files were modified
FILES_MODIFIED=0

# Get list of staged TypeScript files
STAGED_TS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\\.ts$' || true)

if [ -z "$STAGED_TS_FILES" ]; then
    exit 0
fi

for file in $STAGED_TS_FILES; do
    # Skip if file doesn't exist
    [ ! -f "$file" ] && continue
    
    if ! has_copyright_header "$file"; then
        echo "Adding copyright header to: $file"
        create_copyright_header "$file" "$GIT_USER_NAME" "$GIT_USER_EMAIL" "$CURRENT_YEAR"
        git add "$file"
        FILES_MODIFIED=1
    else
        FIRST_YEAR=$(get_first_year "$file")
        
        if [ -n "$FIRST_YEAR" ]; then
            if ! update_year_in_header "$file" "$FIRST_YEAR" "$CURRENT_YEAR"; then
                echo "Updated copyright year in: $file"
                git add "$file"
                FILES_MODIFIED=1
            fi
        fi
        
        if ! user_in_header "$file" "$GIT_USER_EMAIL"; then
            echo "Adding contributor to: $file"
            add_contributor_to_header "$file" "$GIT_USER_NAME" "$GIT_USER_EMAIL"
            git add "$file"
            FILES_MODIFIED=1
        fi
    fi
done

if [ "$FILES_MODIFIED" -eq 1 ]; then
    echo ""
    echo "Copyright headers have been updated. Changes have been staged."
fi

exit 0
`;
}

/**
 * Generates the content for the commit-msg hook (conventional commits).
 */
export function generateCommitMsgHook(): string {
  return `#!/bin/sh
#----------------------------------------------------------------------------------------------------
# Conventional commits enforcement hook
# Auto-generated by ante.
#----------------------------------------------------------------------------------------------------

commit_msg_file=$1
commit_msg=$(cat "$commit_msg_file")
pattern="^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert): .{1,50}"

if ! echo "$commit_msg" | grep -qE "$pattern"; then
  echo "Error: Commit message does not follow Conventional Commits format."
  echo "Format: <type>: <subject>"
  echo "Example: feat: add new feature"
  exit 1
fi
`;
}

/**
 * Installs the git hooks to the specified directory.
 *
 * @param targetDir - The project root directory
 * @param config - The resolved configuration
 * @returns Promise resolving when installation is complete
 */
export async function installHook(
  targetDir: string,
  config: ResolvedConfig,
): Promise<void> {
  const hooksDir = `${targetDir}/${HOOKS_DIR}`;

  // Create hooks directory
  await Deno.mkdir(hooksDir, { recursive: true });

  // Write functions.sh
  const functionsPath = `${hooksDir}/functions.sh`;
  await Deno.writeTextFile(functionsPath, generateFunctionsScript(config));
  await Deno.chmod(functionsPath, 0o755);

  // Write pre-commit hook
  const preCommitPath = `${hooksDir}/pre-commit`;
  await Deno.writeTextFile(preCommitPath, generatePreCommitHook());
  await Deno.chmod(preCommitPath, 0o755);

  // Write commit-msg hook
  const commitMsgPath = `${hooksDir}/commit-msg`;
  await Deno.writeTextFile(commitMsgPath, generateCommitMsgHook());
  await Deno.chmod(commitMsgPath, 0o755);

  // Configure git to use the hooks directory
  const cmd = new Deno.Command("git", {
    args: ["config", "core.hooksPath", HOOKS_DIR],
    cwd: targetDir,
    stdout: "null",
    stderr: "null",
  });

  await cmd.output();
}

/**
 * Removes the installed hooks and resets git configuration.
 *
 * @param targetDir - The project root directory
 * @returns Promise resolving when uninstallation is complete
 */
export async function uninstallHook(targetDir: string): Promise<void> {
  const hooksDir = `${targetDir}/${HOOKS_DIR}`;

  // Remove hooks directory
  try {
    await Deno.remove(hooksDir, { recursive: true });
  } catch {
    // Directory might not exist
  }

  // Reset git hooks path
  const cmd = new Deno.Command("git", {
    args: ["config", "--unset", "core.hooksPath"],
    cwd: targetDir,
    stdout: "null",
    stderr: "null",
  });

  await cmd.output();
}

/**
 * Checks if hooks are installed.
 *
 * @param targetDir - The project root directory
 * @returns Promise resolving to true if hooks are installed
 */
export async function hooksInstalled(targetDir: string): Promise<boolean> {
  const hooksDir = `${targetDir}/${HOOKS_DIR}`;

  try {
    const stat = await Deno.stat(`${hooksDir}/pre-commit`);
    return stat.isFile;
  } catch {
    return false;
  }
}
